<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
        name="viewport">
  <meta content="ie=edge" http-equiv="X-UA-Compatible">
  <title>Document</title>
</head>
<body>
<div id="app" style="padding: 20px">
  <div style="color: red">
    {{name}}hello {{age}} hello
  </div>
  <span>{{age}}</span>
  <ul>
    <li>{{name}}</li>
    <li>{{age}}</li>
  </ul>
</div>
</body>
<script src="../dist/vue.js"></script>
<script>
  // 响应式的数据变化，数据变化了我们可以监听到数据的变化
  // 数据的取值和更改值
  const vm = new Vue({
    el: '#app',
    data: { // 代理数据
      name: '珠峰',
      age: 20,
      address: {
        content: '天通苑',
        number: 30
      },
      hobby: ['eat', 'drink', {a: 1}]
    }
  })
  console.log(vm)
  vm.name = "孙悟空"
  console.log(vm.name)

  setTimeout(() => {
    vm.name = "猪八戒"
    console.log("进行手动更新")
    vm._update(vm._render()) // 进行手动更新
    // 如果属性和视图可以关联起来，做到数据变化可以自动更新视图（观察者模式）就可以达到目的了
  }, 1500)

  vm.address.content = "回龙观"

  // 修改数组很少用索引，但是内部做劫持会浪费性能
  // 用户一般修改数组，通常会使用数组的方法：push shift concat 等等
  vm.hobby.unshift({b: 2})
  console.log(vm)

  // 1. 模板引擎，性能差，需要正则匹配替换，1.0的时候，没有引入虚拟DOM
  // 2. 采用虚拟DOM，数据变化后比较虚拟DOM的差异，最后更新需要更新的地方
  // 3. 核心就是我们需要将 模板编程我们的 js 语法，通过js语法生成虚拟DOM

  // 从一个东西变为 另一个东西，语法之间的转化： es6 -> es5
  // css 压缩，我们需要先把语法树木在重新组装代码成为新的语法


</script>
</html>